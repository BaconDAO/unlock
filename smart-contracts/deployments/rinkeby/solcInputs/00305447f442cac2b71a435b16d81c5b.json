{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/hooks/ILockKeyCancelHook.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n/**\n * @notice Functions to be implemented by a keyCancelHook.\n * @dev Lock hooks are configured by calling `setEventHooks` on the lock.\n */\ninterface ILockKeyCancelHook\n{\n  /**\n   * @notice If the lock owner has registered an implementer\n   * then this hook is called with every key cancel.\n   * @param operator the msg.sender issuing the cancel\n   * @param to the account which had the key canceled\n   * @param refund the amount sent to the `to` account (ETH or a ERC-20 token)\n   */\n  function onKeyCancel(\n    address operator,\n    address to,\n    uint256 refund\n  ) external;\n}"
    },
    "contracts/test-artifacts/TestEventHooks.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '../interfaces/hooks/ILockKeyPurchaseHook.sol';\nimport '../interfaces/hooks/ILockKeyCancelHook.sol';\nimport '../interfaces/IPublicLock.sol';\n\n\n/**\n * @title Test contract for lock event hooks.\n * @author Nick Mancuso (unlock-protocol.com)\n */\ncontract TestEventHooks is ILockKeyPurchaseHook, ILockKeyCancelHook\n{\n  event OnKeyPurchase(\n    address lock,\n    address from,\n    address recipient,\n    address referrer,\n    uint minKeyPrice,\n    uint pricePaid\n  );\n  event OnKeyCancel(\n    address lock,\n    address operator,\n    address to,\n    uint refund\n  );\n\n  uint public discount;\n  bool public isPurchaseSupported;\n\n  function configure(\n    bool _isPurchaseSupported,\n    uint _discount\n  ) public\n  {\n    isPurchaseSupported = _isPurchaseSupported;\n    discount = _discount;\n  }\n\n  function onKeyPurchase(\n    address _from,\n    address _recipient,\n    address _referrer,\n    bytes calldata /*_data*/,\n    uint _minKeyPrice,\n    uint _pricePaid\n  ) external\n  {\n    emit OnKeyPurchase(msg.sender, _from, _recipient, _referrer, _minKeyPrice, _pricePaid);\n  }\n\n  function keyPurchasePrice(\n    address /*from*/,\n    address /*recipient*/,\n    address /*referrer*/,\n    bytes calldata /*data*/\n  ) external view\n    returns (uint minKeyPrice)\n  {\n    require(isPurchaseSupported, 'PURCHASE_BLOCKED_BY_HOOK');\n    minKeyPrice = IPublicLock(msg.sender).keyPrice();\n    if(discount < minKeyPrice)\n    {\n      minKeyPrice -= discount;\n    }\n    else\n    {\n      minKeyPrice = 0;\n    }\n  }\n\n  function onKeyCancel(\n    address _operator,\n    address _to,\n    uint _refund\n  ) external\n  {\n    emit OnKeyCancel(msg.sender, _operator, _to, _refund);\n  }\n}"
    },
    "contracts/interfaces/hooks/ILockKeyPurchaseHook.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n/**\n * @notice Functions to be implemented by a keyPurchaseHook.\n * @dev Lock hooks are configured by calling `setEventHooks` on the lock.\n */\ninterface ILockKeyPurchaseHook\n{\n  /**\n   * @notice Used to determine the purchase price before issueing a transaction.\n   * This allows the hook to offer a discount on purchases.\n   * This may revert to prevent a purchase.\n   * @param from the msg.sender making the purchase\n   * @param recipient the account which will be granted a key\n   * @param referrer the account which referred this key sale\n   * @param data arbitrary data populated by the front-end which initiated the sale\n   * @return the minimum value/price required to purchase a key with these settings\n   * @dev the lock's address is the `msg.sender` when this function is called via\n   * the lock's `purchasePriceFor` function\n   */\n  function keyPurchasePrice(\n    address from,\n    address recipient,\n    address referrer,\n    bytes calldata data\n  ) external view\n    returns (uint minKeyPrice);\n\n  /**\n   * @notice If the lock owner has registered an implementer then this hook\n   * is called with every key sold.\n   * @param from the msg.sender making the purchase\n   * @param recipient the account which will be granted a key\n   * @param referrer the account which referred this key sale\n   * @param data arbitrary data populated by the front-end which initiated the sale\n   * @param minKeyPrice the price including any discount granted from calling this\n   * hook's `keyPurchasePrice` function\n   * @param pricePaid the value/pricePaid included with the purchase transaction\n   * @dev the lock's address is the `msg.sender` when this function is called\n   */\n  function onKeyPurchase(\n    address from,\n    address recipient,\n    address referrer,\n    bytes calldata data,\n    uint minKeyPrice,\n    uint pricePaid\n  ) external;\n}\n"
    },
    "contracts/interfaces/IPublicLock.sol": {
      "content": "pragma solidity 0.5.17;\n\n/**\n* @title The PublicLock Interface\n* @author Nick Furfaro (unlock-protocol.com)\n */\n\n\ncontract IPublicLock\n{\n\n// See indentationissue description here:\n// https://github.com/duaraghav8/Ethlint/issues/268\n// solium-disable indentation\n\n  /// Functions\n\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) external;\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  function() external payable;\n\n  /**\n   * @dev Never used directly\n   */\n  function initialize() external;\n\n  /**\n  * @notice The version number of the current implementation on this network.\n  * @return The current version number.\n  */\n  function publicLockVersion() public pure returns (uint);\n\n  /**\n  * @notice Gets the current balance of the account provided.\n  * @param _tokenAddress The token type to retrieve the balance of.\n  * @param _account The account to get the balance of.\n  * @return The number of tokens of the given type for the given address, possibly 0.\n  */\n  function getBalance(\n    address _tokenAddress,\n    address _account\n  ) external view\n    returns (uint);\n\n  /**\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\n  * @dev Throws if called by other than a lock manager.\n  * @dev Throws if lock contract has already been disabled.\n  */\n  function disableLock() external;\n\n  /**\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @dev Throws if called by other than a lock manager or beneficiary\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external;\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) external\n    returns (bool);\n\n  /**\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if lock has been disabled\n   * @dev Throws if _tokenAddress is not a valid token\n   * @param _keyPrice The new price to set for keys\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\n   * or 0 to use ETH\n   */\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\n\n  /**\n   * A function which lets a Lock manager update the beneficiary account,\n   * which receives funds on withdrawal.\n   * @dev Throws if called by other than a Lock manager or beneficiary\n   * @dev Throws if _beneficiary is address(0)\n   * @param _beneficiary The new address to set as the beneficiary\n   */\n  function updateBeneficiary( address _beneficiary ) external;\n\n    /**\n   * Checks if the user has a non-expired key.\n   * @param _user The address of the key owner\n   */\n  function getHasValidKey(\n    address _user\n  ) external view returns (bool);\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n   * @param _account The address of the key owner\n  */\n  function getTokenIdFor(\n    address _account\n  ) external view returns (uint);\n\n  /**\n  * A function which returns a subset of the keys for this Lock as an array\n  * @param _page the page of key owners requested when faceted by page size\n  * @param _pageSize the number of Key Owners requested per page\n  * @dev Throws if there are no key owners yet\n  */\n  function getOwnersByPage(\n    uint _page,\n    uint _pageSize\n  ) external view returns (address[] memory);\n\n  /**\n   * Checks if the given address owns the given tokenId.\n   * @param _tokenId The tokenId of the key to check\n   * @param _keyOwner The potential key owners address\n   */\n  function isKeyOwner(\n    uint _tokenId,\n    address _keyOwner\n  ) external view returns (bool);\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) external view returns (uint timestamp);\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners() external view returns (uint);\n\n  /**\n   * Allows a Lock manager to assign a descriptive name for this Lock.\n   * @param _lockName The new name for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external;\n\n  /**\n   * Allows a Lock manager to assign a Symbol for this Lock.\n   * @param _lockSymbol The new Symbol for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external;\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token symbol\n    */\n  function symbol()\n    external view\n    returns(string memory);\n\n    /**\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\n   * @dev Throws if called by other than a Lock manager\n   * @param _baseTokenURI String representing the base of the URI for this lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external;\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n   *  Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   * @param _tokenId The tokenID we're inquiring about\n   * @return String representing the URI for the requested token\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external view returns(string memory);\n\n  /**\n   * @notice Allows a Lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external;\n\n  /**\n   * Allows a Lock manager to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   * @dev Throws if called by other than a Lock manager\n   * @param _recipients An array of receiving addresses\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external;\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable;\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint);\n\n  /**\n   * Allow a Lock manager to change the transfer fee.\n   * @dev Throws if called by other than a Lock manager\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\n   * Ex: 200 bps = 2%\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  ) external;\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @dev Throws if _keyOwner does not have a valid key\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   * @param _time The amount of time to calculate the fee for.\n   * @return The transfer fee in seconds.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  ) external view returns (uint);\n\n  /**\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\n   * @param _keyOwner The key owner to whom we wish to send a refund to\n   * @param amount The amount to refund the key-owner\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if _keyOwner does not have a valid key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external;\n\n   /**\n   * @dev allows the key manager to expire a given tokenId\n   * and send a refund to the keyOwner based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId) external;\n\n  /**\n   * @dev Cancels a key managed by a different user and sends the funds to the keyOwner.\n   * @param _keyManager the key managed by this user will be canceled\n   * @param _v _r _s getCancelAndRefundApprovalHash signed by the _keyManager\n   * @param _tokenId The key to cancel\n   */\n  function cancelAndRefundFor(\n    address _keyManager,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    uint _tokenId\n  ) external;\n\n  /**\n   * @notice Sets the minimum nonce for a valid off-chain approval message from the\n   * senders account.\n   * @dev This can be used to invalidate a previously signed message.\n   */\n  function invalidateOffchainApproval(\n    uint _nextAvailableNonce\n  ) external;\n\n  /**\n   * Allow a Lock manager to change the refund penalty.\n   * @dev Throws if called by other than a Lock manager\n   * @param _freeTrialLength The new duration of free trials for this lock\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external;\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * @param _keyOwner The key owner to get the refund value for.\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  ) external view returns (uint refund);\n\n  function keyManagerToNonce(address ) external view returns (uint256 );\n\n  /**\n   * @notice returns the hash to sign in order to allow another user to cancel on your behalf.\n   * @dev this can be computed in JS instead of read from the contract.\n   * @param _keyManager The key manager's address (also the message signer)\n   * @param _txSender The address cancelling cancel on behalf of the keyOwner\n   * @return approvalHash The hash to sign\n   */\n  function getCancelAndRefundApprovalHash(\n    address _keyManager,\n    address _txSender\n  ) external view returns (bytes32 approvalHash);\n\n  function addKeyGranter(address account) external;\n\n  function addLockManager(address account) external;\n\n  function isKeyGranter(address account) external view returns (bool);\n\n  function isLockManager(address account) external view returns (bool);\n\n  function onKeyPurchaseHook() external view returns(address);\n\n  function onKeyCancelHook() external view returns(address);\n\n  function revokeKeyGranter(address _granter) external;\n\n  function renounceLockManager() external;\n\n  ///===================================================================\n  /// Auto-generated getter functions from public state variables\n\n  function beneficiary() external view returns (address );\n\n  function expirationDuration() external view returns (uint256 );\n\n  function freeTrialLength() external view returns (uint256 );\n\n  function isAlive() external view returns (bool );\n\n  function keyPrice() external view returns (uint256 );\n\n  function maxNumberOfKeys() external view returns (uint256 );\n\n  function owners(uint256 ) external view returns (address );\n\n  function refundPenaltyBasisPoints() external view returns (uint256 );\n\n  function tokenAddress() external view returns (address );\n\n  function transferFeeBasisPoints() external view returns (uint256 );\n\n  function unlockProtocol() external view returns (address );\n\n  function keyManagerOf(uint) external view returns (address );\n\n  ///===================================================================\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @dev Throws if key is not valid.\n  * @dev Throws if `_to` is the zero address\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @dev Emit Transfer event\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) external;\n\n  /**\n  * @notice Update transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address to assign the rights to for the given key\n  */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) external;\n\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n  ///===================================================================\n\n  /// From ERC165.sol\n  function supportsInterface(bytes4 interfaceId) external view returns (bool );\n  ///===================================================================\n\n  /// From ERC-721\n  /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address _owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n\n    /**\n    * @notice Get the approved address for a single NFT\n    * @dev Throws if `_tokenId` is not a valid NFT.\n    * @param _tokenId The NFT to find the approved address for\n    * @return The approved address for this NFT, or the zero address if there is none\n    */\n    function getApproved(uint256 _tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address _owner, address operator) public view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address _owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n\n\n\n    /**\n     * @notice An ERC-20 style transfer.\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n     */\n    function transfer(\n      address _to,\n      uint _value\n    ) external\n      returns (bool success);\n}\n"
    },
    "contracts/Unlock.sol": {
      "content": "pragma solidity 0.5.17;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol';\nimport '@openzeppelin/upgrades/contracts/Initializable.sol';\nimport 'hardlydifficult-ethereum-contracts/contracts/proxies/Clone2Factory.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IUnlock.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from “most base-like” to “most derived”.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  IUnlock,\n  Initializable,\n  Ownable\n{\n  using Address for address;\n  using Clone2Factory for address;\n  using SafeMath for uint;\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the public lock template, used when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via zos).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable.sol\n    Ownable.initialize(_unlockOwner);\n  }\n\n  /**\n  * @dev Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\n  * @param _salt an identifier for the Lock, which is unique for the user.\n  * This may be implemented as a sequence ID or with RNG. It's used with `create2`\n  * to know the lock's address before the transaction is mined.\n  */\n  function createLock(\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string memory _lockName,\n    bytes12 _salt\n  ) public\n  {\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // create lock\n    bytes32 salt;\n    // solium-disable-next-line\n    assembly\n    {\n      let pointer := mload(0x40)\n      // The salt is the msg.sender\n      mstore(pointer, shl(96, caller))\n      // followed by the _salt provided\n      mstore(add(pointer, 0x14), _salt)\n      salt := mload(pointer)\n    }\n    address payable newLock = address(uint160(publicLockAddress.createClone2(salt)));\n    IPublicLock(newLock).initialize(\n      msg.sender,\n      _expirationDuration,\n      _tokenAddress,\n      _keyPrice,\n      _maxNumberOfKeys,\n      _lockName\n    );\n\n    // Assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    view\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct.add(valueInETH);\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice).mul(125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul(valueInETH) / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply().mul(valueInETH) / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute.mul(20) / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 9;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address payable _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/upgrades/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "hardlydifficult-ethereum-contracts/contracts/proxies/Clone2Factory.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n// From https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n// Updated to support Solidity 5, switch to `create2` and revert on fail\nlibrary Clone2Factory\n{\n  /**\n   * @notice Uses create2 to deploy a clone to a pre-determined address.\n   * @param target the address of the template contract, containing the logic for this contract.\n   * @param salt a salt used to determine the contract address before the transaction is mined,\n   * may be random or sequential.\n   * The salt to use with the create2 call can be `msg.sender+salt` in order to\n   * prevent an attacker from front-running another user's deployment.\n   * @return proxyAddress the address of the newly deployed contract.\n   * @dev Using `bytes12` for the salt saves 6 gas over using `uint96` (requires another shift).\n   * Will revert on fail.\n   */\n  function createClone2(\n    address target,\n    bytes32 salt\n  ) internal\n    returns (address proxyAddress)\n  {\n    // solium-disable-next-line\n    assembly\n    {\n      let pointer := mload(0x40)\n\n      // Create the bytecode for deployment based on the Minimal Proxy Standard (EIP-1167)\n      // bytecode: 0x0\n      mstore(pointer, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(pointer, 0x14), shl(96, target))\n      mstore(add(pointer, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      // `create2` consumes all available gas if called with a salt that's already been consumed\n      // we check if the address is available first so that doesn't happen\n      // Costs ~958 gas\n\n      // Calculate the hash\n      let contractCodeHash := keccak256(pointer, 0x37)\n\n      // salt: 0x100\n      mstore(add(pointer, 0x100), salt)\n\n      // addressSeed: 0x40\n      // 0xff\n      mstore(add(pointer, 0x40), 0xff00000000000000000000000000000000000000000000000000000000000000)\n      // this\n      mstore(add(pointer, 0x41), shl(96, address))\n      // salt\n      mstore(add(pointer, 0x55), mload(add(pointer, 0x100)))\n      // hash\n      mstore(add(pointer, 0x75), contractCodeHash)\n\n      proxyAddress := keccak256(add(pointer, 0x40), 0x55)\n\n      switch extcodesize(proxyAddress)\n      case 0 {\n        // Deploy the contract, returning the address or 0 on fail\n        proxyAddress := create2(0, pointer, 0x37, mload(add(pointer, 0x100)))\n      }\n      default {\n        proxyAddress := 0\n      }\n    }\n\n    // Revert if the deployment fails (possible if salt was already used)\n    require(proxyAddress != address(0), 'PROXY_DEPLOY_FAILED');\n  }\n}\n"
    },
    "contracts/interfaces/IUnlock.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n/**\n * @title The Unlock Interface\n * @author Nick Furfaro (unlock-protocol.com)\n**/\n\ninterface IUnlock\n{\n  // Use initialize instead of a constructor to support proxies(for upgradeability via zos).\n  function initialize(address _unlockOwner) external;\n\n  /**\n  * @dev Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\n  * @param _salt an identifier for the Lock, which is unique for the user.\n  * This may be implemented as a sequence ID or with RNG. It's used with `create2`\n  * to know the lock's address before the transaction is mined.\n  */\n  function createLock(\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName,\n    bytes12 _salt\n  ) external;\n\n    /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer // solhint-disable-line no-unused-vars\n  )\n    external;\n\n    /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint _tokens // solhint-disable-line no-unused-vars\n  )\n    external;\n\n    /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   */\n  function computeAvailableDiscountFor(\n    address _purchaser, // solhint-disable-line no-unused-vars\n    uint _keyPrice // solhint-disable-line no-unused-vars\n  )\n    external\n    view\n    returns(uint discount, uint tokens);\n\n  // Function to read the globalTokenURI field.\n  function globalBaseTokenURI()\n    external\n    view\n    returns(string memory);\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory);\n\n  // Function to read the globalTokenSymbol field.\n  function globalTokenSymbol()\n    external\n    view\n    returns(string memory);\n\n  // Function to read the chainId field.\n  function chainId()\n    external\n    view\n    returns(uint);\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory);\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  )\n    external;\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address payable _publicLockAddress\n  ) external;\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external;\n\n  function grossNetworkProduct() external view returns(uint);\n\n  function totalDiscountGranted() external view returns(uint);\n\n  function locks(address) external view returns(bool deployed, uint totalSales, uint yieldedDiscountTokens);\n\n  // The address of the public lock template, used when `createLock` is called\n  function publicLockAddress() external view returns(address);\n\n  // Map token address to exchange contract address if the token is supported\n  // Used for GDP calculations\n  function uniswapOracles(address) external view returns(address);\n\n  // The WETH token address, used for value calculations\n  function weth() external view returns(address);\n\n  // The UDT token address, used to mint tokens on referral\n  function udt() external view returns(address);\n\n  // The approx amount of gas required to purchase a key\n  function estimatedGasForPurchase() external view returns(uint);\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion() external pure returns(uint16);\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external;\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isOwner() external view returns(bool);\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() external view returns(address);\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() external;\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) external;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IUniswapOracle\n{\n    function PERIOD() external returns (uint);\n    function factory() external returns (address);\n    function update(\n      address _tokenIn,\n      address _tokenOut\n    ) external;\n    function consult(\n      address _tokenIn,\n      uint _amountIn,\n      address _tokenOut\n    ) external view\n      returns (uint _amountOut);\n    function updateAndConsult(\n      address _tokenIn,\n      uint _amountIn,\n      address _tokenOut\n    ) external\n      returns (uint _amountOut);\n}"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IMintableERC20.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IMintableERC20\n{\n  function mint(address account, uint256 amount) external returns (bool);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function totalSupply() external returns (uint);\n  function balanceOf(address account) external returns (uint256);\n}"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Initializable, Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./ERC20.sol\";\nimport \"../../lifecycle/Pausable.sol\";\n\n/**\n * @title Pausable token\n * @dev ERC20 with pausable transfers and allowances.\n *\n * Useful if you want to stop trades until the end of a crowdsale, or have\n * an emergency switch for freezing all token transfers in the event of a large\n * bug.\n */\ncontract ERC20Pausable is Initializable, ERC20, Pausable {\n    function initialize(address sender) public initializer {\n        Pausable.initialize(sender);\n    }\n\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/lifecycle/Pausable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../GSN/Context.sol\";\nimport \"../access/roles/PauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Initializable, Context, PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    function initialize(address sender) public initializer {\n        PauserRole.initialize(sender);\n\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/roles/PauserRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract PauserRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    function initialize(address sender) public initializer {\n        if (!isPauser(sender)) {\n            _addPauser(sender);\n        }\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract MinterRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is Initializable, IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/mixins/MixinTransfer.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport './MixinLockManagerRole.sol';\nimport './MixinDisable.sol';\nimport './MixinKeys.sol';\nimport './MixinFunds.sol';\nimport './MixinLockCore.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol';\n\n/**\n * @title Mixin for the transfer-related functions needed to meet the ERC721\n * standard.\n * @author Nick Furfaro\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\n\ncontract MixinTransfer is\n  MixinLockManagerRole,\n  MixinFunds,\n  MixinLockCore,\n  MixinKeys\n{\n  using SafeMath for uint;\n  using Address for address;\n\n  event TransferFeeChanged(\n    uint transferFeeBasisPoints\n  );\n\n  // 0x150b7a02 == bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // The fee relative to keyPrice to charge when transfering a Key to another account\n  // (potentially on a 0x marketplace).\n  // This is calculated as `keyPrice * transferFeeBasisPoints / BASIS_POINTS_DEN`.\n  uint public transferFeeBasisPoints;\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) public\n    onlyIfAlive\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_to != address(0), 'INVALID_ADDRESS');\n    address keyOwner = _ownerOf[_tokenId];\n    require(getHasValidKey(keyOwner), 'KEY_NOT_VALID');\n    Key storage fromKey = keyByOwner[keyOwner];\n    Key storage toKey = keyByOwner[_to];\n    uint idTo = toKey.tokenId;\n    uint time;\n    // get the remaining time for the origin key\n    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;\n    // get the transfer fee based on amount of time wanted share\n    uint fee = getTransferFee(keyOwner, _timeShared);\n    uint timePlusFee = _timeShared.add(fee);\n\n    // ensure that we don't try to share too much\n    if(timePlusFee < timeRemaining) {\n      // now we can safely set the time\n      time = _timeShared;\n      // deduct time from parent key, including transfer fee\n      _timeMachine(_tokenId, timePlusFee, false);\n    } else {\n      // we have to recalculate the fee here\n      fee = getTransferFee(keyOwner, timeRemaining);\n      time = timeRemaining - fee;\n      fromKey.expirationTimestamp = block.timestamp; // Effectively expiring the key\n      emit ExpireKey(_tokenId);\n    }\n\n    if (idTo == 0) {\n      _assignNewTokenId(toKey);\n      idTo = toKey.tokenId;\n      _recordOwner(_to, idTo);\n      emit Transfer(\n        address(0), // This is a creation or time-sharing\n        _to,\n        idTo\n      );\n    } else if (toKey.expirationTimestamp <= block.timestamp) {\n      // reset the key Manager for expired keys\n      _setKeyManagerOf(idTo, address(0));\n    }\n\n    // add time to new key\n    _timeMachine(idTo, time, true);\n    // trigger event\n    emit Transfer(\n      keyOwner,\n      _to,\n      idTo\n    );\n\n    require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');\n  }\n\n  function transferFrom(\n    address _from,\n    address _recipient,\n    uint _tokenId\n  )\n    public\n    onlyIfAlive\n    hasValidKey(_from)\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(isKeyOwner(_tokenId, _from), 'TRANSFER_FROM: NOT_KEY_OWNER');\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_recipient != address(0), 'INVALID_ADDRESS');\n    uint fee = getTransferFee(_from, 0);\n\n    Key storage fromKey = keyByOwner[_from];\n    Key storage toKey = keyByOwner[_recipient];\n\n    uint previousExpiration = toKey.expirationTimestamp;\n    // subtract the fee from the senders key before the transfer\n    _timeMachine(_tokenId, fee, false);\n\n    if (toKey.tokenId == 0) {\n      toKey.tokenId = _tokenId;\n      _recordOwner(_recipient, _tokenId);\n      // Clear any previous approvals\n      _clearApproval(_tokenId);\n    }\n\n    if (previousExpiration <= block.timestamp) {\n      // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n      // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n      toKey.expirationTimestamp = fromKey.expirationTimestamp;\n      toKey.tokenId = _tokenId;\n\n      // Reset the key Manager to the key owner\n      _setKeyManagerOf(_tokenId, address(0));\n\n      _recordOwner(_recipient, _tokenId);\n    } else {\n      // The recipient has a non expired key. We just add them the corresponding remaining time\n      // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\n      toKey.expirationTimestamp = fromKey\n        .expirationTimestamp.add(previousExpiration - block.timestamp);\n    }\n\n    // Effectively expiring the key for the previous owner\n    fromKey.expirationTimestamp = block.timestamp;\n\n    // Set the tokenID to 0 for the previous owner to avoid duplicates\n    fromKey.tokenId = 0;\n\n    // trigger event\n    emit Transfer(\n      _from,\n      _recipient,\n      _tokenId\n    );\n  }\n\n  /**\n   * @notice An ERC-20 style transfer.\n   * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n   * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n   * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n   */\n  function transfer(\n    address _to,\n    uint _value\n  ) public\n    returns (bool success)\n  {\n    uint maxTimeToSend = _value * expirationDuration;\n    Key storage fromKey = keyByOwner[msg.sender];\n    uint timeRemaining = fromKey.expirationTimestamp.sub(block.timestamp);\n    if(maxTimeToSend < timeRemaining)\n    {\n      shareKey(_to, fromKey.tokenId, maxTimeToSend);\n    }\n    else\n    {\n      transferFrom(msg.sender, _to, fromKey.tokenId);\n    }\n\n    // Errors will cause a revert\n    return true;\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address\n  * @dev This works identically to the other function with an extra data parameter,\n  *  except this function just sets data to ''\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId\n  )\n    public\n  {\n    safeTransferFrom(_from, _to, _tokenId, '');\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address.\n  * When transfer is complete, this functions\n  *  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  *  `onERC721Received` on `_to` and throws if the return value is not\n  *  `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  * @param _data Additional data with no specified format, sent in call to `_to`\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    bytes memory _data\n  )\n    public\n  {\n    transferFrom(_from, _to, _tokenId);\n    require(_checkOnERC721Received(_from, _to, _tokenId, _data), 'NON_COMPLIANT_ERC721_RECEIVER');\n\n  }\n\n  /**\n   * Allow the Lock owner to change the transfer fee.\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  )\n    external\n    onlyLockManager\n  {\n    emit TransferFeeChanged(\n      _transferFeeBasisPoints\n    );\n    transferFeeBasisPoints = _transferFeeBasisPoints;\n  }\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  )\n    public view\n    returns (uint)\n  {\n    if(! getHasValidKey(_keyOwner)) {\n      return 0;\n    } else {\n      Key storage key = keyByOwner[_keyOwner];\n      uint timeToTransfer;\n      uint fee;\n      // Math: safeSub is not required since `hasValidKey` confirms timeToTransfer is positive\n      // this is for standard key transfers\n      if(_time == 0) {\n        timeToTransfer = key.expirationTimestamp - block.timestamp;\n      } else {\n        timeToTransfer = _time;\n      }\n      fee = timeToTransfer.mul(transferFeeBasisPoints) / BASIS_POINTS_DEN;\n      return fee;\n    }\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n}"
    },
    "contracts/mixins/MixinLockManagerRole.sol": {
      "content": "pragma solidity 0.5.17;\n\n// This contract mostly follows the pattern established by openzeppelin in\n// openzeppelin/contracts-ethereum-package/contracts/access/roles\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol';\n\n\ncontract MixinLockManagerRole {\n  using Roles for Roles.Role;\n\n  event LockManagerAdded(address indexed account);\n  event LockManagerRemoved(address indexed account);\n\n  Roles.Role private lockManagers;\n\n  function _initializeMixinLockManagerRole(address sender) internal {\n    if (!isLockManager(sender)) {\n      lockManagers.add(sender);\n    }\n  }\n\n  modifier onlyLockManager() {\n    require(isLockManager(msg.sender), 'MixinLockManager: caller does not have the LockManager role');\n    _;\n  }\n\n  function isLockManager(address account) public view returns (bool) {\n    return lockManagers.has(account);\n  }\n\n  function addLockManager(address account) public onlyLockManager {\n    lockManagers.add(account);\n    emit LockManagerAdded(account);\n  }\n\n  function renounceLockManager() public {\n    lockManagers.remove(msg.sender);\n    emit LockManagerRemoved(msg.sender);\n  }\n}\n"
    },
    "contracts/mixins/MixinDisable.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport './MixinFunds.sol';\nimport './MixinLockManagerRole.sol';\n\n/**\n * @title Mixin allowing the Lock owner to disable a Lock (preventing new purchases)\n * and then destroy it.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinDisable is\n  MixinLockManagerRole,\n  MixinFunds\n{\n  // Used to disable payable functions when deprecating an old lock\n  bool public isAlive;\n\n  event Disable();\n\n  function _initializeMixinDisable(\n  ) internal\n  {\n    isAlive = true;\n  }\n\n  // Only allow usage when contract is Alive\n  modifier onlyIfAlive() {\n    require(isAlive, 'LOCK_DEPRECATED');\n    _;\n  }\n\n  /**\n  * @dev Used to disable lock before migrating keys and/or destroying contract\n   */\n  function disableLock()\n    external\n    onlyLockManager\n    onlyIfAlive\n  {\n    emit Disable();\n    isAlive = false;\n  }\n}"
    },
    "contracts/mixins/MixinKeys.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport './MixinLockCore.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol';\n\n\n/**\n * @title Mixin for managing `Key` data, as well as the * Approval related functions needed to meet the ERC721\n * standard.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinKeys is\n  MixinLockCore\n{\n  using SafeMath for uint;\n\n  // The struct for a key\n  struct Key {\n    uint tokenId;\n    uint expirationTimestamp;\n  }\n\n  // Emitted when the Lock owner expires a user's Key\n  event ExpireKey(uint indexed tokenId);\n\n  // Emitted when the expiration of a key is modified\n  event ExpirationChanged(\n    uint indexed _tokenId,\n    uint _amount,\n    bool _timeAdded\n  );\n\n  event KeyManagerChanged(uint indexed _tokenId, address indexed _newManager);\n\n\n  // Keys\n  // Each owner can have at most exactly one key\n  // TODO: could we use public here? (this could be confusing though because it getter will\n  // return 0 values when missing a key)\n  mapping (address => Key) internal keyByOwner;\n\n  // Each tokenId can have at most exactly one owner at a time.\n  // Returns 0 if the token does not exist\n  // TODO: once we decouple tokenId from owner address (incl in js), then we can consider\n  // merging this with totalSupply into an array instead.\n  mapping (uint => address) internal _ownerOf;\n\n  // Addresses of owners are also stored in an array.\n  // Addresses are never removed by design to avoid abuses around referals\n  address[] public owners;\n\n  // A given key has both an owner and a manager.\n  // If keyManager == address(0) then the key owner is also the manager\n  // Each key can have at most 1 keyManager.\n  mapping (uint => address) public keyManagerOf;\n\n    // Keeping track of approved transfers\n  // This is a mapping of addresses which have approved\n  // the transfer of a key to another address where their key can be transferred\n  // Note: the approver may actually NOT have a key... and there can only\n  // be a single approved address\n  mapping (uint => address) private approved;\n\n    // Keeping track of approved operators for a given Key manager.\n  // This approves a given operator for all keys managed by the calling \"keyManager\"\n  // The caller may not currently be the keyManager for ANY keys.\n  // These approvals are never reset/revoked automatically, unlike \"approved\",\n  // which is reset on transfer.\n  mapping (address => mapping (address => bool)) private managerToOperatorApproved;\n\n    // Ensure that the caller is the keyManager of the key\n  // or that the caller has been approved\n  // for ownership of that key\n  modifier onlyKeyManagerOrApproved(\n    uint _tokenId\n  )\n  {\n    require(\n      _isKeyManager(_tokenId, msg.sender) ||\n      _isApproved(_tokenId, msg.sender) ||\n      isApprovedForAll(_ownerOf[_tokenId], msg.sender),\n      'ONLY_KEY_MANAGER_OR_APPROVED'\n    );\n    _;\n  }\n\n  // Ensures that an owner owns or has owned a key in the past\n  modifier ownsOrHasOwnedKey(\n    address _keyOwner\n  ) {\n    require(\n      keyByOwner[_keyOwner].expirationTimestamp > 0, 'HAS_NEVER_OWNED_KEY'\n    );\n    _;\n  }\n\n  // Ensures that an owner has a valid key\n  modifier hasValidKey(\n    address _user\n  ) {\n    require(\n      getHasValidKey(_user), 'KEY_NOT_VALID'\n    );\n    _;\n  }\n\n  // Ensures that a key has an owner\n  modifier isKey(\n    uint _tokenId\n  ) {\n    require(\n      _ownerOf[_tokenId] != address(0), 'NO_SUCH_KEY'\n    );\n    _;\n  }\n\n  // Ensure that the caller owns the key\n  modifier onlyKeyOwner(\n    uint _tokenId\n  ) {\n    require(\n      isKeyOwner(_tokenId, msg.sender), 'ONLY_KEY_OWNER'\n    );\n    _;\n  }\n\n  /**\n   * In the specific case of a Lock, each owner can own only at most 1 key.\n   * @return The number of NFTs owned by `_keyOwner`, either 0 or 1.\n  */\n  function balanceOf(\n    address _keyOwner\n  )\n    public\n    view\n    returns (uint)\n  {\n    require(_keyOwner != address(0), 'INVALID_ADDRESS');\n    return getHasValidKey(_keyOwner) ? 1 : 0;\n  }\n\n  /**\n   * Checks if the user has a non-expired key.\n   */\n  function getHasValidKey(\n    address _keyOwner\n  )\n    public\n    view\n    returns (bool)\n  {\n    return keyByOwner[_keyOwner].expirationTimestamp > block.timestamp;\n  }\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n  */\n  function getTokenIdFor(\n    address _account\n  ) public view\n    returns (uint)\n  {\n    return keyByOwner[_account].tokenId;\n  }\n\n /**\n  * A function which returns a subset of the keys for this Lock as an array\n  * @param _page the page of key owners requested when faceted by page size\n  * @param _pageSize the number of Key Owners requested per page\n  */\n  function getOwnersByPage(uint _page, uint _pageSize)\n    public\n    view\n    returns (address[] memory)\n  {\n    uint pageSize = _pageSize;\n    uint _startIndex = _page * pageSize;\n    uint endOfPageIndex;\n\n    if (_startIndex + pageSize > owners.length) {\n      endOfPageIndex = owners.length;\n      pageSize = owners.length - _startIndex;\n    } else {\n      endOfPageIndex = (_startIndex + pageSize);\n    }\n\n    // new temp in-memory array to hold pageSize number of requested owners:\n    address[] memory ownersByPage = new address[](pageSize);\n    uint pageIndex = 0;\n\n    // Build the requested set of owners into a new temporary array:\n    for (uint i = _startIndex; i < endOfPageIndex; i++) {\n      ownersByPage[pageIndex] = owners[i];\n      pageIndex++;\n    }\n\n    return ownersByPage;\n  }\n\n  /**\n   * Checks if the given address owns the given tokenId.\n   */\n  function isKeyOwner(\n    uint _tokenId,\n    address _keyOwner\n  ) public view\n    returns (bool)\n  {\n    return _ownerOf[_tokenId] == _keyOwner;\n  }\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) public view\n    returns (uint)\n  {\n    return keyByOwner[_keyOwner].expirationTimestamp;\n  }\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners()\n    public\n    view\n    returns (uint)\n  {\n    return owners.length;\n  }\n  // Returns the owner of a given tokenId\n  function ownerOf(\n    uint _tokenId\n  ) public view\n    returns(address)\n  {\n    return _ownerOf[_tokenId];\n  }\n\n  /**\n  * @notice Public function for updating transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address with the manager's rights for the given key.\n  * Setting _keyManager to address(0) means the keyOwner is also the keyManager\n   */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) public\n    isKey(_tokenId)\n  {\n    require(\n      _isKeyManager(_tokenId, msg.sender) ||\n      isLockManager(msg.sender),\n      'UNAUTHORIZED_KEY_MANAGER_UPDATE'\n    );\n    _setKeyManagerOf(_tokenId, _keyManager);\n  }\n\n  function _setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) internal\n  {\n    if(keyManagerOf[_tokenId] != _keyManager) {\n      keyManagerOf[_tokenId] = _keyManager;\n      _clearApproval(_tokenId);\n      emit KeyManagerChanged(_tokenId, address(0));\n    }\n  }\n\n    /**\n   * This approves _approved to get ownership of _tokenId.\n   * Note: that since this is used for both purchase and transfer approvals\n   * the approved token may not exist.\n   */\n  function approve(\n    address _approved,\n    uint _tokenId\n  )\n    public\n    onlyIfAlive\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(msg.sender != _approved, 'APPROVE_SELF');\n\n    approved[_tokenId] = _approved;\n    emit Approval(_ownerOf[_tokenId], _approved, _tokenId);\n  }\n\n    /**\n   * @notice Get the approved address for a single NFT\n   * @dev Throws if `_tokenId` is not a valid NFT.\n   * @param _tokenId The NFT to find the approved address for\n   * @return The approved address for this NFT, or the zero address if there is none\n   */\n  function getApproved(\n    uint _tokenId\n  ) public view\n    isKey(_tokenId)\n    returns (address)\n  {\n    address approvedRecipient = approved[_tokenId];\n    return approvedRecipient;\n  }\n\n    /**\n   * @dev Tells whether an operator is approved by a given keyManager\n   * @param _owner owner address which you want to query the approval of\n   * @param _operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  ) public view\n    returns (bool)\n  {\n    uint tokenId = keyByOwner[_owner].tokenId;\n    address keyManager = keyManagerOf[tokenId];\n    if(keyManager == address(0)) {\n      return managerToOperatorApproved[_owner][_operator];\n    } else {\n      return managerToOperatorApproved[keyManager][_operator];\n    }\n  }\n\n  /**\n  * Returns true if _keyManager is the manager of the key\n  * identified by _tokenId\n   */\n  function _isKeyManager(\n    uint _tokenId,\n    address _keyManager\n  ) internal view\n    returns (bool)\n  {\n    if(keyManagerOf[_tokenId] == _keyManager ||\n      (keyManagerOf[_tokenId] == address(0) && isKeyOwner(_tokenId, _keyManager))) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Assigns the key a new tokenId (from totalSupply) if it does not already have\n   * one assigned.\n   */\n  function _assignNewTokenId(\n    Key storage _key\n  ) internal\n  {\n    if (_key.tokenId == 0) {\n      // This is a brand new owner\n      // We increment the tokenId counter\n      _totalSupply++;\n      // we assign the incremented `_totalSupply` as the tokenId for the new key\n      _key.tokenId = _totalSupply;\n    }\n  }\n\n  /**\n   * Records the owner of a given tokenId\n   */\n  function _recordOwner(\n    address _keyOwner,\n    uint _tokenId\n  ) internal\n  {\n    if (_ownerOf[_tokenId] != _keyOwner) {\n      // TODO: this may include duplicate entries\n      owners.push(_keyOwner);\n      // We register the owner of the tokenID\n      _ownerOf[_tokenId] = _keyOwner;\n    }\n  }\n\n  /**\n  * @notice Modify the expirationTimestamp of a key\n  * by a given amount.\n  * @param _tokenId The ID of the key to modify.\n  * @param _deltaT The amount of time in seconds by which\n  * to modify the keys expirationTimestamp\n  * @param _addTime Choose whether to increase or decrease\n  * expirationTimestamp (false == decrease, true == increase)\n  * @dev Throws if owner does not have a valid key.\n  */\n  function _timeMachine(\n    uint _tokenId,\n    uint256 _deltaT,\n    bool _addTime\n  ) internal\n  {\n    address tokenOwner = _ownerOf[_tokenId];\n    require(tokenOwner != address(0), 'NON_EXISTENT_KEY');\n    Key storage key = keyByOwner[tokenOwner];\n    uint formerTimestamp = key.expirationTimestamp;\n    bool validKey = getHasValidKey(tokenOwner);\n    if(_addTime) {\n      if(validKey) {\n        key.expirationTimestamp = formerTimestamp.add(_deltaT);\n      } else {\n        key.expirationTimestamp = block.timestamp.add(_deltaT);\n      }\n    } else {\n      key.expirationTimestamp = formerTimestamp.sub(_deltaT);\n    }\n    emit ExpirationChanged(_tokenId, _deltaT, _addTime);\n  }\n\n    /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param _to operator address to set the approval\n   * @param _approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(\n    address _to,\n    bool _approved\n  ) public\n    onlyIfAlive\n  {\n    require(_to != msg.sender, 'APPROVE_SELF');\n    managerToOperatorApproved[msg.sender][_to] = _approved;\n    emit ApprovalForAll(msg.sender, _to, _approved);\n  }\n\n    /**\n   * @dev Checks if the given user is approved to transfer the tokenId.\n   */\n  function _isApproved(\n    uint _tokenId,\n    address _user\n  ) internal view\n    returns (bool)\n  {\n    return approved[_tokenId] == _user;\n  }\n\n    /**\n   * @dev Function to clear current approval of a given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(\n    uint256 _tokenId\n  ) internal\n  {\n    if (approved[_tokenId] != address(0)) {\n      approved[_tokenId] = address(0);\n    }\n  }\n}\n"
    },
    "contracts/mixins/MixinFunds.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol';\n\n\n/**\n * @title An implementation of the money related functions.\n * @author HardlyDifficult (unlock-protocol.com)\n */\ncontract MixinFunds\n{\n  using Address for address payable;\n  using SafeERC20 for IERC20;\n\n  /**\n   * The token-type that this Lock is priced in.  If 0, then use ETH, else this is\n   * a ERC20 token address.\n   */\n  address public tokenAddress;\n\n  function _initializeMixinFunds(\n    address _tokenAddress\n  ) internal\n  {\n    tokenAddress = _tokenAddress;\n    require(\n      _tokenAddress == address(0) || IERC20(_tokenAddress).totalSupply() > 0,\n      'INVALID_TOKEN'\n    );\n  }\n\n  /**\n   * Gets the current balance of the account provided.\n   */\n  function getBalance(\n    address _tokenAddress,\n    address _account\n  ) public view\n    returns (uint)\n  {\n    if(_tokenAddress == address(0)) {\n      return _account.balance;\n    } else {\n      return IERC20(_tokenAddress).balanceOf(_account);\n    }\n  }\n\n  /**\n   * Transfers funds from the contract to the account provided.\n   *\n   * Security: be wary of re-entrancy when calling this function.\n   */\n  function _transfer(\n    address _tokenAddress,\n    address _to,\n    uint _amount\n  ) internal\n  {\n    if(_amount > 0) {\n      if(_tokenAddress == address(0)) {\n        // https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\n        address(uint160(_to)).sendValue(_amount);\n      } else {\n        IERC20 token = IERC20(_tokenAddress);\n        token.safeTransfer(_to, _amount);\n      }\n    }\n  }\n}"
    },
    "contracts/mixins/MixinLockCore.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Enumerable.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol';\nimport './MixinDisable.sol';\nimport './MixinLockManagerRole.sol';\nimport '../interfaces/IUnlock.sol';\nimport './MixinFunds.sol';\nimport '../interfaces/hooks/ILockKeyCancelHook.sol';\nimport '../interfaces/hooks/ILockKeyPurchaseHook.sol';\n\n\n/**\n * @title Mixin for core lock data and functions.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinLockCore is\n  IERC721Enumerable,\n  MixinLockManagerRole,\n  MixinFunds,\n  MixinDisable\n{\n  using Address for address;\n\n  event Withdrawal(\n    address indexed sender,\n    address indexed tokenAddress,\n    address indexed beneficiary,\n    uint amount\n  );\n\n  event PricingChanged(\n    uint oldKeyPrice,\n    uint keyPrice,\n    address oldTokenAddress,\n    address tokenAddress\n  );\n\n  // Unlock Protocol address\n  // TODO: should we make that private/internal?\n  IUnlock public unlockProtocol;\n\n  // Duration in seconds for which the keys are valid, after creation\n  // should we take a smaller type use less gas?\n  // TODO: add support for a timestamp instead of duration\n  uint public expirationDuration;\n\n  // price in wei of the next key\n  // TODO: allow support for a keyPriceCalculator which could set prices dynamically\n  uint public keyPrice;\n\n  // Max number of keys sold if the keyReleaseMechanism is public\n  uint public maxNumberOfKeys;\n\n  // A count of how many new key purchases there have been\n  uint internal _totalSupply;\n\n  // The account which will receive funds on withdrawal\n  address public beneficiary;\n\n  // The denominator component for values specified in basis points.\n  uint internal constant BASIS_POINTS_DEN = 10000;\n\n  ILockKeyPurchaseHook public onKeyPurchaseHook;\n  ILockKeyCancelHook public onKeyCancelHook;\n\n  // Ensure that the Lock has not sold all of its keys.\n  modifier notSoldOut() {\n    require(maxNumberOfKeys > _totalSupply, 'LOCK_SOLD_OUT');\n    _;\n  }\n\n  modifier onlyLockManagerOrBeneficiary()\n  {\n    require(\n      isLockManager(msg.sender) || msg.sender == beneficiary,\n      'ONLY_LOCK_MANAGER_OR_BENEFICIARY'\n    );\n    _;\n  }\n\n  function _initializeMixinLockCore(\n    address _beneficiary,\n    uint _expirationDuration,\n    uint _keyPrice,\n    uint _maxNumberOfKeys\n  ) internal\n  {\n    require(_expirationDuration <= 100 * 365 * 24 * 60 * 60, 'MAX_EXPIRATION_100_YEARS');\n    unlockProtocol = IUnlock(msg.sender); // Make sure we link back to Unlock's smart contract.\n    beneficiary = _beneficiary;\n    expirationDuration = _expirationDuration;\n    keyPrice = _keyPrice;\n    maxNumberOfKeys = _maxNumberOfKeys;\n  }\n\n  // The version number of the current implementation on this network\n  function publicLockVersion(\n  ) public pure\n    returns (uint)\n  {\n    return 8;\n  }\n\n  /**\n   * @dev Called by owner to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *\n   * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external\n    onlyLockManagerOrBeneficiary\n  {\n    uint balance = getBalance(_tokenAddress, address(this));\n    uint amount;\n    if(_amount == 0 || _amount > balance)\n    {\n      require(balance > 0, 'NOT_ENOUGH_FUNDS');\n      amount = balance;\n    }\n    else\n    {\n      amount = _amount;\n    }\n\n    emit Withdrawal(msg.sender, _tokenAddress, beneficiary, amount);\n    // Security: re-entrancy not a risk as this is the last line of an external function\n    _transfer(_tokenAddress, beneficiary, amount);\n  }\n\n  /**\n   * A function which lets the owner of the lock change the pricing for future purchases.\n   * This consists of 2 parts: The token address and the price in the given token.\n   * In order to set the token to ETH, use 0 for the token Address.\n   */\n  function updateKeyPricing(\n    uint _keyPrice,\n    address _tokenAddress\n  )\n    external\n    onlyLockManager\n    onlyIfAlive\n  {\n    uint oldKeyPrice = keyPrice;\n    address oldTokenAddress = tokenAddress;\n    require(\n      _tokenAddress == address(0) || IERC20(_tokenAddress).totalSupply() > 0,\n      'INVALID_TOKEN'\n    );\n    keyPrice = _keyPrice;\n    tokenAddress = _tokenAddress;\n    emit PricingChanged(oldKeyPrice, keyPrice, oldTokenAddress, tokenAddress);\n  }\n\n  /**\n   * A function which lets the owner of the lock update the beneficiary account,\n   * which receives funds on withdrawal.\n   */\n  function updateBeneficiary(\n    address _beneficiary\n  ) external\n  {\n    require(msg.sender == beneficiary || isLockManager(msg.sender), 'ONLY_BENEFICIARY_OR_LOCKMANAGER');\n    require(_beneficiary != address(0), 'INVALID_ADDRESS');\n    beneficiary = _beneficiary;\n  }\n\n  /**\n   * @notice Allows a lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external\n    onlyLockManager()\n  {\n    require(_onKeyPurchaseHook == address(0) || _onKeyPurchaseHook.isContract(), 'INVALID_ON_KEY_SOLD_HOOK');\n    require(_onKeyCancelHook == address(0) || _onKeyCancelHook.isContract(), 'INVALID_ON_KEY_CANCEL_HOOK');\n    onKeyPurchaseHook = ILockKeyPurchaseHook(_onKeyPurchaseHook);\n    onKeyCancelHook = ILockKeyCancelHook(_onKeyCancelHook);\n  }\n\n  function totalSupply()\n    public\n    view returns(uint256)\n  {\n    return _totalSupply;\n  }\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) public\n    onlyLockManagerOrBeneficiary\n    returns (bool)\n  {\n    return IERC20(tokenAddress).approve(_spender, _amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is Initializable, IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is Initializable, IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/PublicLock.sol": {
      "content": "pragma solidity 0.5.17;\n\n\nimport './interfaces/IPublicLock.sol';\nimport '@openzeppelin/upgrades/contracts/Initializable.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/introspection/ERC165.sol';\nimport './mixins/MixinDisable.sol';\nimport './mixins/MixinERC721Enumerable.sol';\nimport './mixins/MixinFunds.sol';\nimport './mixins/MixinGrantKeys.sol';\nimport './mixins/MixinKeys.sol';\nimport './mixins/MixinLockCore.sol';\nimport './mixins/MixinLockMetadata.sol';\nimport './mixins/MixinPurchase.sol';\nimport './mixins/MixinRefunds.sol';\nimport './mixins/MixinTransfer.sol';\nimport './mixins/MixinSignatures.sol';\nimport './mixins/MixinLockManagerRole.sol';\nimport './mixins/MixinKeyGranterRole.sol';\n\n\n/**\n * @title The Lock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\n * Every ERC-721 compliant contract must implement the ERC165 interface.\n * https://eips.ethereum.org/EIPS/eip-721\n */\ncontract PublicLock is\n  IPublicLock,\n  Initializable,\n  ERC165,\n  MixinLockManagerRole,\n  MixinKeyGranterRole,\n  MixinSignatures,\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys,\n  MixinLockMetadata,\n  MixinERC721Enumerable,\n  MixinGrantKeys,\n  MixinPurchase,\n  MixinTransfer,\n  MixinRefunds\n{\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string memory _lockName\n  ) public\n    initializer()\n  {\n    MixinFunds._initializeMixinFunds(_tokenAddress);\n    MixinDisable._initializeMixinDisable();\n    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);\n    MixinLockMetadata._initializeMixinLockMetadata(_lockName);\n    MixinERC721Enumerable._initializeMixinERC721Enumerable();\n    MixinRefunds._initializeMixinRefunds();\n    MixinLockManagerRole._initializeMixinLockManagerRole(_lockCreator);\n    MixinKeyGranterRole._initializeMixinKeyGranterRole(_lockCreator);\n    // registering the interface for erc721 with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x80ac58cd);\n  }\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  function() external payable {}\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/introspection/ERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is Initializable, IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function initialize() public initializer {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/mixins/MixinERC721Enumerable.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport './MixinKeys.sol';\nimport './MixinLockCore.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Enumerable.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/introspection/ERC165.sol';\n\n\n/**\n * @title Implements the ERC-721 Enumerable extension.\n */\ncontract MixinERC721Enumerable is\n  IERC721Enumerable,\n  ERC165,\n  MixinLockCore, // Implements totalSupply\n  MixinKeys\n{\n  function _initializeMixinERC721Enumerable() internal\n  {\n    /**\n     * register the supported interface to conform to ERC721Enumerable via ERC165\n     * 0x780e9d63 ===\n     *     bytes4(keccak256('totalSupply()')) ^\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\n     */\n    _registerInterface(0x780e9d63);\n  }\n\n  /// @notice Enumerate valid NFTs\n  /// @dev Throws if `_index` >= `totalSupply()`.\n  /// @param _index A counter less than `totalSupply()`\n  /// @return The token identifier for the `_index`th NFT,\n  ///  (sort order not specified)\n  function tokenByIndex(\n    uint256 _index\n  ) public view\n    returns (uint256)\n  {\n    require(_index < _totalSupply, 'OUT_OF_RANGE');\n    return _index;\n  }\n\n  /// @notice Enumerate NFTs assigned to an owner\n  /// @dev Throws if `_index` >= `balanceOf(_keyOwner)` or if\n  ///  `_keyOwner` is the zero address, representing invalid NFTs.\n  /// @param _keyOwner An address where we are interested in NFTs owned by them\n  /// @param _index A counter less than `balanceOf(_keyOwner)`\n  /// @return The token identifier for the `_index`th NFT assigned to `_keyOwner`,\n  ///   (sort order not specified)\n  function tokenOfOwnerByIndex(\n    address _keyOwner,\n    uint256 _index\n  ) public view\n    returns (uint256)\n  {\n    require(_index == 0, 'ONLY_ONE_KEY_PER_OWNER');\n    return getTokenIdFor(_keyOwner);\n  }\n}"
    },
    "contracts/mixins/MixinGrantKeys.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport './MixinKeys.sol';\nimport './MixinKeyGranterRole.sol';\n\n\n/**\n * @title Mixin allowing the Lock owner to grant / gift keys to users.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinGrantKeys is\n  MixinKeyGranterRole,\n  MixinKeys\n{\n  /**\n   * Allows the Lock owner to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external\n    onlyKeyGranterOrManager\n  {\n    for(uint i = 0; i < _recipients.length; i++) {\n      address recipient = _recipients[i];\n      uint expirationTimestamp = _expirationTimestamps[i];\n      address keyManager = _keyManagers[i];\n\n      require(recipient != address(0), 'INVALID_ADDRESS');\n\n      Key storage toKey = keyByOwner[recipient];\n      require(expirationTimestamp > toKey.expirationTimestamp, 'ALREADY_OWNS_KEY');\n\n      uint idTo = toKey.tokenId;\n\n      if(idTo == 0) {\n        _assignNewTokenId(toKey);\n        idTo = toKey.tokenId;\n        _recordOwner(recipient, idTo);\n      }\n      // Set the key Manager\n      _setKeyManagerOf(idTo, keyManager);\n      emit KeyManagerChanged(idTo, keyManager);\n\n      toKey.expirationTimestamp = expirationTimestamp;\n      // trigger event\n      emit Transfer(\n        address(0), // This is a creation.\n        recipient,\n        idTo\n      );\n    }\n  }\n}\n"
    },
    "contracts/mixins/MixinLockMetadata.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/introspection/ERC165.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Enumerable.sol';\nimport '../UnlockUtils.sol';\nimport './MixinKeys.sol';\nimport './MixinLockCore.sol';\nimport './MixinLockManagerRole.sol';\n\n/**\n * @title Mixin for metadata about the Lock.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinLockMetadata is\n  IERC721Enumerable,\n  ERC165,\n  MixinLockManagerRole,\n  MixinLockCore,\n  MixinKeys\n{\n  using UnlockUtils for uint;\n  using UnlockUtils for address;\n  using UnlockUtils for string;\n\n  /// A descriptive name for a collection of NFTs in this contract.Defaults to \"Unlock-Protocol\" but is settable by lock owner\n  string public name;\n\n  /// An abbreviated name for NFTs in this contract. Defaults to \"KEY\" but is settable by lock owner\n  string private lockSymbol;\n\n  // the base Token URI for this Lock. If not set by lock owner, the global URI stored in Unlock is used.\n  string private baseTokenURI;\n\n  event NewLockSymbol(\n    string symbol\n  );\n\n  function _initializeMixinLockMetadata(\n    string memory _lockName\n  ) internal\n  {\n    ERC165.initialize();\n    name = _lockName;\n    // registering the optional erc721 metadata interface with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x5b5e139f);\n  }\n\n  /**\n   * Allows the Lock owner to assign a descriptive name for this Lock.\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external\n    onlyLockManager\n  {\n    name = _lockName;\n  }\n\n  /**\n   * Allows the Lock owner to assign a Symbol for this Lock.\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external\n    onlyLockManager\n  {\n    lockSymbol = _lockSymbol;\n    emit NewLockSymbol(_lockSymbol);\n  }\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token name\n    */\n  function symbol()\n    external view\n    returns(string memory)\n  {\n    if(bytes(lockSymbol).length == 0) {\n      return unlockProtocol.globalTokenSymbol();\n    } else {\n      return lockSymbol;\n    }\n  }\n\n  /**\n   * Allows the Lock owner to update the baseTokenURI for this Lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external\n    onlyLockManager\n  {\n    baseTokenURI = _baseTokenURI;\n  }\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @param _tokenId The iD of the token  for which we want to retrieve the URI.\n   * If 0 is passed here, we just return the appropriate baseTokenURI.\n   * If a custom URI has been set we don't return the lock address.\n   * It may be included in the custom baseTokenURI if needed.\n   * @dev  URIs are defined in RFC 3986. The URI may point to a JSON file\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external\n    view\n    returns(string memory)\n  {\n    string memory URI;\n    string memory tokenId;\n    string memory lockAddress = address(this).address2Str();\n    string memory seperator;\n\n    if(_tokenId != 0) {\n      tokenId = _tokenId.uint2Str();\n    } else {\n      tokenId = '';\n    }\n\n    if(bytes(baseTokenURI).length == 0) {\n      URI = unlockProtocol.globalBaseTokenURI();\n      seperator = '/';\n    } else {\n      URI = baseTokenURI;\n      seperator = '';\n      lockAddress = '';\n    }\n\n    return URI.strConcat(\n        lockAddress,\n        seperator,\n        tokenId\n      );\n  }\n}"
    },
    "contracts/mixins/MixinPurchase.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport './MixinDisable.sol';\nimport './MixinKeys.sol';\nimport './MixinLockCore.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol';\nimport './MixinFunds.sol';\n\n\n/**\n * @title Mixin for the purchase-related functions.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinPurchase is\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys\n{\n  using SafeMath for uint;\n\n  event RenewKeyPurchase(address indexed owner, uint newExpiration);\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if the lock owner increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable\n    onlyIfAlive\n    notSoldOut\n  {\n    require(_recipient != address(0), 'INVALID_ADDRESS');\n\n    // Assign the key\n    Key storage toKey = keyByOwner[_recipient];\n    uint idTo = toKey.tokenId;\n    uint newTimeStamp;\n\n    if (idTo == 0) {\n      // Assign a new tokenId (if a new owner or previously transferred)\n      _assignNewTokenId(toKey);\n      // refresh the cached value\n      idTo = toKey.tokenId;\n      _recordOwner(_recipient, idTo);\n      newTimeStamp = block.timestamp + expirationDuration;\n      toKey.expirationTimestamp = newTimeStamp;\n\n      // trigger event\n      emit Transfer(\n        address(0), // This is a creation.\n        _recipient,\n        idTo\n      );\n    } else if (toKey.expirationTimestamp > block.timestamp) {\n      // This is an existing owner trying to extend their key\n      newTimeStamp = toKey.expirationTimestamp.add(expirationDuration);\n      toKey.expirationTimestamp = newTimeStamp;\n      emit RenewKeyPurchase(_recipient, newTimeStamp);\n    } else {\n      // This is an existing owner trying to renew their expired key\n      // SafeAdd is not required here since expirationDuration is capped to a tiny value\n      // (relative to the size of a uint)\n      newTimeStamp = block.timestamp + expirationDuration;\n      toKey.expirationTimestamp = newTimeStamp;\n\n      // reset the key Manager to 0x00\n      _setKeyManagerOf(idTo, address(0));\n\n      emit RenewKeyPurchase(_recipient, newTimeStamp);\n    }\n\n    (uint inMemoryKeyPrice, uint discount, uint tokens) = _purchasePriceFor(_recipient, _referrer, _data);\n    if (discount > 0)\n    {\n      unlockProtocol.recordConsumedDiscount(discount, tokens);\n    }\n\n    // Record price without any tips\n    unlockProtocol.recordKeyPurchase(inMemoryKeyPrice, getHasValidKey(_referrer) && _referrer != _recipient ? _referrer : address(0));\n\n    // We explicitly allow for greater amounts of ETH or tokens to allow 'donations'\n    uint pricePaid;\n    if(tokenAddress != address(0))\n    {\n      pricePaid = _value;\n      IERC20 token = IERC20(tokenAddress);\n      token.safeTransferFrom(msg.sender, address(this), _value);\n    }\n    else\n    {\n      pricePaid = msg.value;\n    }\n    require(pricePaid >= inMemoryKeyPrice, 'INSUFFICIENT_VALUE');\n\n    if(address(onKeyPurchaseHook) != address(0))\n    {\n      onKeyPurchaseHook.onKeyPurchase(msg.sender, _recipient, _referrer, _data, inMemoryKeyPrice, pricePaid);\n    }\n  }\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev minKeyPrice considers any discount from Unlock or the OnKeyPurchase hook\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint minKeyPrice)\n  {\n    (minKeyPrice, , ) = _purchasePriceFor(_recipient, _referrer, _data);\n  }\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev minKeyPrice considers any discount from Unlock or the OnKeyPurchase hook\n   * unlockDiscount and unlockTokens are the values returned from `computeAvailableDiscountFor`\n   */\n  function _purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes memory _data\n  ) internal view\n    returns (uint minKeyPrice, uint unlockDiscount, uint unlockTokens)\n  {\n    if(address(onKeyPurchaseHook) != address(0))\n    {\n      minKeyPrice = onKeyPurchaseHook.keyPurchasePrice(msg.sender, _recipient, _referrer, _data);\n    }\n    else\n    {\n      minKeyPrice = keyPrice;\n    }\n\n    if(minKeyPrice > 0)\n    {\n      (unlockDiscount, unlockTokens) = unlockProtocol.computeAvailableDiscountFor(_recipient, minKeyPrice);\n      require(unlockDiscount <= minKeyPrice, 'INVALID_DISCOUNT_FROM_UNLOCK');\n      minKeyPrice -= unlockDiscount;\n    }\n  }\n}\n"
    },
    "contracts/mixins/MixinRefunds.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol';\nimport './MixinSignatures.sol';\nimport './MixinKeys.sol';\nimport './MixinLockCore.sol';\nimport './MixinLockManagerRole.sol';\nimport './MixinFunds.sol';\n\n\ncontract MixinRefunds is\n  MixinLockManagerRole,\n  MixinSignatures,\n  MixinFunds,\n  MixinLockCore,\n  MixinKeys\n{\n  using SafeMath for uint;\n\n  // CancelAndRefund will return funds based on time remaining minus this penalty.\n  // This is calculated as `proRatedRefund * refundPenaltyBasisPoints / BASIS_POINTS_DEN`.\n  uint public refundPenaltyBasisPoints;\n\n  uint public freeTrialLength;\n\n  /// @notice The typehash per the EIP-712 standard\n  /// @dev This can be computed in JS instead of read from the contract\n  bytes32 private constant CANCEL_TYPEHASH = keccak256('cancelAndRefundFor(address _keyOwner)');\n\n  event CancelKey(\n    uint indexed tokenId,\n    address indexed owner,\n    address indexed sendTo,\n    uint refund\n  );\n\n  event RefundPenaltyChanged(\n    uint freeTrialLength,\n    uint refundPenaltyBasisPoints\n  );\n\n  function _initializeMixinRefunds() internal\n  {\n    // default to 10%\n    refundPenaltyBasisPoints = 1000;\n  }\n\n  /**\n   * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation\n   * of the key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external\n    onlyLockManager\n    hasValidKey(_keyOwner)\n  {\n    _cancelAndRefund(_keyOwner, amount);\n  }\n\n  /**\n   * @dev Destroys the key and sends a refund based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId)\n    external\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    address keyOwner = ownerOf(_tokenId);\n    uint refund = _getCancelAndRefundValue(keyOwner);\n\n    _cancelAndRefund(keyOwner, refund);\n  }\n\n  /**\n   * @dev Cancels a key managed by a different user and sends the funds to the msg.sender.\n   * @param _keyManager the key managed by this user will be canceled\n   * @param _v _r _s getCancelAndRefundApprovalHash signed by the _keyOwner\n   * @param _tokenId The key to cancel\n   */\n  function cancelAndRefundFor(\n    address _keyManager,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    uint _tokenId\n  ) external\n    consumeOffchainApproval(\n      getCancelAndRefundApprovalHash(_keyManager, msg.sender),\n      _keyManager,\n      _v,\n      _r,\n      _s\n    )\n  {\n    address keyOwner = ownerOf(_tokenId);\n    uint refund = _getCancelAndRefundValue(keyOwner);\n    _cancelAndRefund(keyOwner, refund);\n  }\n\n  /**\n   * Allow the owner to change the refund penalty.\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external\n    onlyLockManager\n  {\n    emit RefundPenaltyChanged(\n      _freeTrialLength,\n      _refundPenaltyBasisPoints\n    );\n\n    freeTrialLength = _freeTrialLength;\n    refundPenaltyBasisPoints = _refundPenaltyBasisPoints;\n  }\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  )\n    external view\n    returns (uint refund)\n  {\n    return _getCancelAndRefundValue(_keyOwner);\n  }\n\n  /**\n   * @notice returns the hash to sign in order to allow another user to cancel on your behalf.\n   * @dev this can be computed in JS instead of read from the contract.\n   * @param _keyManager The key manager's address (also the message signer)\n   * @param _txSender The address cancelling cancel on behalf of the keyOwner\n   * @return approvalHash The hash to sign\n   */\n  function getCancelAndRefundApprovalHash(\n    address _keyManager,\n    address _txSender\n  ) public view\n    returns (bytes32 approvalHash)\n  {\n    return keccak256(\n      abi.encodePacked(\n        // Approval is specific to this Lock\n        address(this),\n        // The specific function the signer is approving\n        CANCEL_TYPEHASH,\n        // Approval enables only one cancel call\n        keyManagerToNonce[_keyManager],\n        // Approval allows only one account to broadcast the tx\n        _txSender\n      )\n    );\n  }\n\n  /**\n   * @dev cancels the key for the given keyOwner and sends the refund to the msg.sender.\n   */\n  function _cancelAndRefund(\n    address _keyOwner,\n    uint refund\n  ) internal\n  {\n    Key storage key = keyByOwner[_keyOwner];\n\n    emit CancelKey(key.tokenId, _keyOwner, msg.sender, refund);\n    // expirationTimestamp is a proxy for hasKey, setting this to `block.timestamp` instead\n    // of 0 so that we can still differentiate hasKey from hasValidKey.\n    key.expirationTimestamp = block.timestamp;\n\n    if (refund > 0) {\n      // Security: doing this last to avoid re-entrancy concerns\n      _transfer(tokenAddress, _keyOwner, refund);\n    }\n\n    // inform the hook if there is one registered\n    if(address(onKeyCancelHook) != address(0))\n    {\n      onKeyCancelHook.onKeyCancel(msg.sender, _keyOwner, refund);\n    }\n  }\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * a cancelAndRefund now.\n   * @param _keyOwner The owner of the key check the refund value for.\n   */\n  function _getCancelAndRefundValue(\n    address _keyOwner\n  )\n    private view\n    hasValidKey(_keyOwner)\n    returns (uint refund)\n  {\n    Key storage key = keyByOwner[_keyOwner];\n    // Math: safeSub is not required since `hasValidKey` confirms timeRemaining is positive\n    uint timeRemaining = key.expirationTimestamp - block.timestamp;\n    if(timeRemaining + freeTrialLength >= expirationDuration) {\n      refund = keyPrice;\n    } else {\n      // Math: using safeMul in case keyPrice or timeRemaining is very large\n      refund = keyPrice.mul(timeRemaining) / expirationDuration;\n    }\n\n    // Apply the penalty if this is not a free trial\n    if(freeTrialLength == 0 || timeRemaining + freeTrialLength < expirationDuration)\n    {\n      uint penalty = keyPrice.mul(refundPenaltyBasisPoints) / BASIS_POINTS_DEN;\n      if (refund > penalty) {\n        // Math: safeSub is not required since the if confirms this won't underflow\n        refund -= penalty;\n      } else {\n        refund = 0;\n      }\n    }\n  }\n}\n"
    },
    "contracts/mixins/MixinSignatures.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/cryptography/ECDSA.sol';\n\n\ncontract MixinSignatures\n{\n  /// @notice emits anytime the nonce used for off-chain approvals changes.\n  event NonceChanged(\n    address indexed keyManager,\n    uint nextAvailableNonce\n  );\n\n  // Stores a nonce per user to use for signed messages\n  mapping(address => uint) public keyManagerToNonce;\n\n  /// @notice Validates an off-chain approval signature.\n  /// @dev If valid the nonce is consumed, else revert.\n  modifier consumeOffchainApproval(\n    bytes32 _hash,\n    address _keyManager,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  {\n    require(\n      ecrecover(\n        ECDSA.toEthSignedMessageHash(_hash),\n        _v,\n        _r,\n        _s\n      ) == _keyManager, 'INVALID_SIGNATURE'\n    );\n    keyManagerToNonce[_keyManager]++;\n    emit NonceChanged(_keyManager, keyManagerToNonce[_keyManager]);\n    _;\n  }\n\n  /**\n   * @notice Sets the minimum nonce for a valid off-chain approval message from the\n   * senders account.\n   * @dev This can be used to invalidate a previously signed message.\n   */\n  function invalidateOffchainApproval(\n    uint _nextAvailableNonce\n  ) external\n  {\n    require(_nextAvailableNonce > keyManagerToNonce[msg.sender], 'NONCE_ALREADY_USED');\n    keyManagerToNonce[msg.sender] = _nextAvailableNonce;\n    emit NonceChanged(msg.sender, _nextAvailableNonce);\n  }\n}"
    },
    "contracts/mixins/MixinKeyGranterRole.sol": {
      "content": "pragma solidity 0.5.17;\n\n// This contract mostly follows the pattern established by openzeppelin in\n// openzeppelin/contracts-ethereum-package/contracts/access/roles\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol';\nimport './MixinLockManagerRole.sol';\n\n\ncontract MixinKeyGranterRole is MixinLockManagerRole {\n  using Roles for Roles.Role;\n\n  event KeyGranterAdded(address indexed account);\n  event KeyGranterRemoved(address indexed account);\n\n  Roles.Role private keyGranters;\n\n  function _initializeMixinKeyGranterRole(address sender) internal {\n    if (!isKeyGranter(sender)) {\n      keyGranters.add(sender);\n    }\n  }\n\n  modifier onlyKeyGranterOrManager() {\n    require(isKeyGranter(msg.sender) || isLockManager(msg.sender), 'MixinKeyGranter: caller does not have the KeyGranter or LockManager role');\n    _;\n  }\n\n  function isKeyGranter(address account) public view returns (bool) {\n    return keyGranters.has(account);\n  }\n\n  function addKeyGranter(address account) public onlyLockManager {\n    keyGranters.add(account);\n    emit KeyGranterAdded(account);\n  }\n\n  function revokeKeyGranter(address _granter) public onlyLockManager {\n    keyGranters.remove(_granter);\n    emit KeyGranterRemoved(_granter);\n  }\n}\n"
    },
    "contracts/UnlockUtils.sol": {
      "content": "pragma solidity 0.5.17;\n\n// This contract provides some utility methods for use with the unlock protocol smart contracts.\n// Borrowed from:\n// https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol#L943\n\nlibrary UnlockUtils {\n\n  function strConcat(\n    string memory _a,\n    string memory _b,\n    string memory _c,\n    string memory _d\n  ) internal pure\n    returns (string memory _concatenatedString)\n  {\n    return string(abi.encodePacked(_a, _b, _c, _d));\n  }\n\n  function uint2Str(\n    uint _i\n  ) internal pure\n    returns (string memory _uintAsString)\n  {\n    // make a copy of the param to avoid security/no-assign-params error\n    uint c = _i;\n    if (_i == 0) {\n      return '0';\n    }\n    uint j = _i;\n    uint len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len - 1;\n    while (c != 0) {\n      bstr[k--] = byte(uint8(48 + c % 10));\n      c /= 10;\n    }\n    return string(bstr);\n  }\n\n  function address2Str(\n    address _addr\n  ) internal pure\n    returns(string memory)\n  {\n    bytes32 value = bytes32(uint256(_addr));\n    bytes memory alphabet = '0123456789abcdef';\n    bytes memory str = new bytes(42);\n    str[0] = '0';\n    str[1] = 'x';\n    for (uint i = 0; i < 20; i++) {\n      str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\n      str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\n    }\n    return string(str);\n  }\n}"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/mocks/TimeMachineMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport '../PublicLock.sol';\n\ncontract TimeMachineMock is\n  PublicLock\n{\n  function timeMachine(\n    uint _tokenId,\n    uint256 _deltaT,\n    bool _addTime\n  ) public\n  {\n    _timeMachine(_tokenId, _deltaT, _addTime);\n  }\n}"
    },
    "contracts/mocks/UnlockUtilsMock.sol": {
      "content": "pragma solidity 0.5.17;\n\n\nimport '../UnlockUtils.sol';\n\n// For testing only.\ncontract UnlockUtilsMock\n{\n  using UnlockUtils for uint;\n  using UnlockUtils for address;\n  using UnlockUtils for string;\n\n  function strConcat(\n    string memory _a,\n    string memory _b,\n    string memory _c,\n    string memory _d\n  ) public pure\n    returns (string memory _concatenatedString)\n  {\n    return _a.strConcat(_b, _c, _d);\n  }\n\n  function uint2Str(\n    uint _i\n  ) public pure\n    returns (string memory _uintAsString)\n  {\n    return _i.uint2Str();\n  }\n\n  function address2Str(\n    address _addr\n  ) public pure\n    returns(string memory)\n  {\n    return _addr.address2Str();\n  }\n}"
    },
    "contracts/mocks/KeyManagerMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport '../PublicLock.sol';\n\ncontract KeyManagerMock is\n  PublicLock\n{\n\n  function isKeyManager(\n    uint _tokenId,\n    address _keyManager\n  ) external view\n    returns (bool)\n  {\n    return(_isKeyManager(_tokenId, _keyManager));\n  }\n\n}"
    },
    "contracts/UnlockDiscountToken.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol';\n\n\n/**\n* @title The Unlock Discount Token\n* This smart contract implements the Unlock Discount Token\n*/\ncontract UnlockDiscountToken is\nERC20Mintable,\nERC20Detailed\n{\n  /**\n   * @notice A one-time call to configure the token.\n   * @param _minter A wallet with permissions to mint tokens and/or add other minters.\n   */\n  function initialize(address _minter) public initializer()\n  {\n    ERC20Mintable.initialize(_minter);\n    ERC20Detailed.initialize('Unlock Discount Token', 'UDT', 18);\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is Initializable, ERC20, MinterRole {\n    function initialize(address sender) public initializer {\n        MinterRole.initialize(sender);\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/test-artifacts/TestErc20PausableToken.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Pausable.sol';\n\n\n/**\n * This is an implementation of a ERC20 token with mint and pause capabilities\n * to be used in tests.\n *\n * This contract should not be used in production.\n */\ncontract TestErc20PausableToken is\n  ERC20Mintable,\n  ERC20Pausable\n{\n  constructor() public\n  {\n    ERC20Pausable.initialize(msg.sender);\n    ERC20Mintable.initialize(msg.sender);\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}